from __future__ import annotations

import hmac
import os
import struct
from hashlib import sha256
from pathlib import Path
from typing import BinaryIO, Iterable, List, Optional, Sequence, Tuple

MAGIC = b"MSDP"
VERSION = 1
HEADER_STRUCT = struct.Struct(">4sH d I I"
)
FRAME_HEADER_STRUCT = struct.Struct(">I I")
ROI_HEADER_STRUCT = struct.Struct(">4I I")
HMAC_SIZE = sha256().digest_size


class DataPackWriter:
    """Helper for writing encrypted ROI metadata into a binary container."""

    def __init__(self, filepath: Path | str, framerate: float, width: int, height: int) -> None:
        self.filepath = Path(filepath)
        self._file: BinaryIO = self.filepath.open("wb")
        self._closed = False
        self._write_header(framerate, width, height)

    def _write_header(self, framerate: float, width: int, height: int) -> None:
        header = HEADER_STRUCT.pack(MAGIC, VERSION, float(framerate), int(width), int(height))
        self._file.write(header)

    def write_frame_data(self, frame_index: int, encrypted_blocks: Sequence[dict]) -> None:
        if self._closed:
            raise RuntimeError("Cannot write to a finalized DataPackWriter")

        blocks = list(encrypted_blocks)
        self._file.write(FRAME_HEADER_STRUCT.pack(int(frame_index), len(blocks)))
        for block in blocks:
            bbox = block.get("bbox")
            encrypted = block.get("encrypted", b"")

            if bbox is None:
                raise ValueError("Encrypted block missing 'bbox' key")
            if not isinstance(encrypted, (bytes, bytearray, memoryview)):
                raise TypeError("Encrypted payload must be bytes-like")

            x1, y1, x2, y2 = (int(coord) for coord in bbox)
            payload = bytes(encrypted)
            self._file.write(ROI_HEADER_STRUCT.pack(x1, y1, x2, y2, len(payload)))
            self._file.write(payload)

    def finalize(self, hmac_key: bytes) -> bytes:
        if self._closed:
            raise RuntimeError("DataPackWriter already finalized")
        if not isinstance(hmac_key, (bytes, bytearray)):
            raise TypeError("hmac_key must be bytes")

        self._file.flush()
        with self.filepath.open("rb") as reader:
            digest = self._compute_hmac(reader, bytes(hmac_key))

        self._file.seek(0, os.SEEK_END)
        self._file.write(digest)
        self._file.flush()
        self._file.close()
        self._closed = True
        return digest

    def _compute_hmac(self, stream: BinaryIO, key: bytes, chunk_size: int = 8192) -> bytes:
        mac = hmac.new(key, digestmod=sha256)
        for chunk in iter(lambda: stream.read(chunk_size), b""):
            mac.update(chunk)
        return mac.digest()

    def close(self) -> None:
        if not self._closed:
            self._file.close()
            self._closed = True

    def __enter__(self) -> "DataPackWriter":
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        if not self._closed:
            self._file.close()
            self._closed = True


class DataPackReader:
    """Read and validate encrypted ROI data packs generated by DataPackWriter."""

    def __init__(self, filepath: Path | str) -> None:
        self.filepath = Path(filepath)
        self._file: BinaryIO = self.filepath.open("rb")
        self._closed = False
        self._file.seek(0, os.SEEK_END)
        self._file_length = self._file.tell()
        if self._file_length < HEADER_STRUCT.size + HMAC_SIZE:
            self.close()
            raise ValueError("数据包文件过小，缺少必要头部或完整性信息")

        self._data_end = self._file_length - HMAC_SIZE
        self._file.seek(0)
        header_bytes = self._file.read(HEADER_STRUCT.size)
        magic, version, framerate, width, height = HEADER_STRUCT.unpack(header_bytes)
        if magic != MAGIC:
            self.close()
            raise ValueError("数据包魔数不匹配，文件可能损坏或格式错误")
        if version != VERSION:
            self.close()
            raise ValueError(f"不支持的数据包版本: {version}")

        self.framerate = framerate
        self.width = width
        self.height = height
        self._frames_start = self._file.tell()

    def iter_frames(self) -> Iterable[Tuple[int, List[dict]]]:
        if self._closed:
            raise RuntimeError("数据包已关闭")

        self._file.seek(self._frames_start)
        position = self._file.tell()

        while position < self._data_end:
            remaining = self._data_end - position
            if remaining < FRAME_HEADER_STRUCT.size:
                break

            frame_header = self._file.read(FRAME_HEADER_STRUCT.size)
            position += FRAME_HEADER_STRUCT.size
            frame_index, block_count = FRAME_HEADER_STRUCT.unpack(frame_header)

            blocks: List[dict] = []
            for _ in range(block_count):
                remaining = self._data_end - position
                if remaining < ROI_HEADER_STRUCT.size:
                    raise ValueError("ROI 头部不完整，数据包可能损坏")

                roi_header = self._file.read(ROI_HEADER_STRUCT.size)
                position += ROI_HEADER_STRUCT.size
                x1, y1, x2, y2, payload_length = ROI_HEADER_STRUCT.unpack(roi_header)

                if payload_length < 0 or self._data_end - position < payload_length:
                    raise ValueError("ROI 数据长度不正确，数据包可能损坏")

                payload = self._file.read(payload_length)
                position += payload_length

                blocks.append(
                    {
                        "bbox": (x1, y1, x2, y2),
                        "encrypted": payload,
                    }
                )

            yield frame_index, blocks

    def verify(self, hmac_key: bytes, chunk_size: int = 8192) -> bool:
        if self._closed:
            raise RuntimeError("数据包已关闭")
        if not isinstance(hmac_key, (bytes, bytearray)):
            raise TypeError("hmac_key 必须为字节序列")

        self._file.seek(self._data_end)
        stored_digest = self._file.read(HMAC_SIZE)

        self._file.seek(0)
        mac = hmac.new(bytes(hmac_key), digestmod=sha256)
        remaining = self._data_end

        while remaining > 0:
            chunk = self._file.read(min(chunk_size, remaining))
            if not chunk:
                break
            mac.update(chunk)
            remaining -= len(chunk)

        calculated = mac.digest()
        return hmac.compare_digest(stored_digest, calculated)

    def close(self) -> None:
        if not self._closed:
            self._file.close()
            self._closed = True

    def __enter__(self) -> "DataPackReader":
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        self.close()
